<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Scroll</title>
  <style>
    html,body { margin:0; height:100%; background:#000; }
    body { overflow-y: scroll; }
    canvas { display:block; position:fixed; top:0; left:0; }
    #scroll-area { height:300vh; }
  </style>
</head>
<body>
  <div id="scroll-area"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js";
    import { gsap } from "https://cdn.jsdelivr.net/npm/gsap@3.13.0/index.js";
    import { ScrollTrigger } from "https://cdn.jsdelivr.net/npm/gsap@3.13.0/ScrollTrigger.js";
    import { createNoise2D, createNoise3D } from "https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.js";
    gsap.registerPlugin(ScrollTrigger);

    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 250;
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    let particleCount = 50000;
    let geometry = new THREE.BufferGeometry();
    let positions = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++){
      let u = Math.random();
      let v = Math.random();
      let theta = u * 2 * Math.PI;
      let phi = Math.acos(2 * v - 1);
      let r = Math.random() * 1000;

      let x = r * Math.sin(phi) * Math.cos(theta);
      let y = r * Math.sin(phi) * Math.sin(theta);
      let z = r * Math.cos(phi);

      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
    }

    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    let material = new THREE.PointsMaterial({
      size: 2.5,
      color: 0xff8800,
      map: new THREE.TextureLoader().load("https://threejs.org/examples/textures/sprites/spark1.png"),
      blending: THREE.AdditiveBlending,
      transparent: true,
      opacity: 1
    });

    let points = new THREE.Points(geometry, material);
    scene.add(points);

    let scatterPositions = positions.slice();
    let scatterBase = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount * 3; i++) {
      scatterBase[i] = scatterPositions[i];
    }

    function updateScatter(time){
      let spatialScale = 0.02, timeScale = 0.3, amplitude = 3;
      for (let i = 0; i < particleCount; i++){
        let x = scatterBase[i * 3];
        let y = scatterBase[i * 3 + 1];
        let z = scatterBase[i * 3 + 2];

        let nx = noise3D(x * spatialScale, y * spatialScale, time * timeScale);
        let ny = noise3D(y * spatialScale, z * spatialScale, time * timeScale + 100);
        let nz = noise3D(z * spatialScale, x * spatialScale, time * timeScale + 200);

        scatterPositions[i * 3] = x + nx * amplitude;
        scatterPositions[i * 3 + 1] = y + ny * amplitude;
        scatterPositions[i * 3 + 2] = z + nz * amplitude;
      }
    }


    let noise2D = createNoise2D(() => 0.75);
    let noise3D = createNoise3D(() => 0.75);

    let R = 80, r = 50;
    let noiseMag = 5;
    let torusUV = new Float32Array(particleCount * 2);
    let torusVel = new Float32Array(particleCount * 2);
    let torusBase = new Float32Array(particleCount * 3);

    let sqrt = Math.floor(Math.sqrt(particleCount));
    for (let i = 0; i < particleCount; i++) {
      let u = 2 * Math.PI * (i % sqrt) / sqrt;
      let v = 2 * Math.PI * (Math.floor((i / sqrt)) / sqrt);
      
      
      const x = (R + r*Math.cos(v)) * Math.cos(u);
      const y = (R + r*Math.cos(v)) * Math.sin(u);
      const z = r * Math.sin(v);

      torusUV[i * 2] = u;
      torusUV[i * 2 + 1] = v;
      torusVel[i * 2] = noise2D(u / noiseMag, v / noiseMag) * 0.01;
      torusVel[i * 2 + 1] = noise2D(u / noiseMag, v / noiseMag) * 0.01;

      torusBase[i * 3] = x
      torusBase[i * 3 + 1] = y
      torusBase[i * 3 + 2] = z
    }

    function updateTorus(time) {
      let spatialScale = 0.02, timeScale = 0.3, amplitude = 2;
      for (let i = 0; i < particleCount; i++) {
        torusUV[i * 2] += torusVel[i * 2];
        torusUV[i * 2 + 1] += torusVel[i * 2 + 1];

        let u = torusUV[i * 2], v = torusUV[i * 2 + 1];
        let bx = (R + r * Math.cos(v)) * Math.cos(u);
        let by = (R + r * Math.cos(v)) * Math.sin(u);
        let bz = r * Math.sin(v);

        let nx = noise3D(bx * spatialScale, by * spatialScale, time * timeScale);
        let ny = noise3D(by * spatialScale, bz * spatialScale, time * timeScale + 100);
        let nz = noise3D(bz * spatialScale, bx * spatialScale, time * timeScale + 200);

        torusBase[i * 3] = bx + nx * amplitude;
        torusBase[i * 3 + 1] = by + ny * amplitude;
        torusBase[i * 3 + 2] = bz + nz * amplitude;
      }
    }

    let sphereRadius = 100;
    let sphereUV = new Float32Array(particleCount * 2);
    let sphereVel = new Float32Array(particleCount * 2);
    let sphereBase = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
      let theta = 2 * Math.PI * (i % sqrt) / sqrt;
      let phi = Math.PI * (Math.floor(i / sqrt) / sqrt);

      let x = sphereRadius * Math.sin(phi) * Math.cos(theta);
      let y = sphereRadius * Math.sin(phi) * Math.sin(theta);
      let z = sphereRadius * Math.cos(phi);

      let newY = z;
      let newZ = -y;
      y = newY;
      z = newZ;

      sphereUV[i * 2] = theta;
      sphereUV[i * 2 + 1] = phi;
      sphereVel[i * 2] = noise2D(theta / noiseMag, phi / noiseMag) * 0.0075;
      sphereVel[i * 2 + 1] = noise2D(theta / noiseMag, phi / noiseMag) * 0.0075;

      sphereBase[i * 3] = x;
      sphereBase[i * 3 + 1] = y;
      sphereBase[i * 3 + 2] = z;
    }



    function updateSphere(time) {
      let spatialScale = 0.02, timeScale = 0.3, amplitude = 2;
      for (let i = 0; i < particleCount; i++) {
        sphereUV[i * 2] += sphereVel[i * 2];
        sphereUV[i * 2 + 1] += sphereVel[i * 2 + 1];

        let theta = sphereUV[i * 2];
        let phi = sphereUV[i * 2 + 1];
        let bx = sphereRadius * Math.sin(phi) * Math.cos(theta);
        let by = sphereRadius * Math.sin(phi) * Math.sin(theta);
        let bz = sphereRadius * Math.cos(phi);

        let temp = bz;
        bz = -by;
        by = temp;
        let nx = noise3D(bx * spatialScale, by * spatialScale, time * timeScale);
        let ny = noise3D(by * spatialScale, bz * spatialScale, time * timeScale + 100);
        let nz = noise3D(bz * spatialScale, bx * spatialScale, time * timeScale + 200);

        sphereBase[i * 3] = bx + nx * amplitude;
        sphereBase[i * 3 + 1] = by + ny * amplitude;
        sphereBase[i * 3 + 2] = bz + nz * amplitude;
      }
    }
    let scrollProgress = 0;
    ScrollTrigger.create({
      trigger: "#scroll-area",
      start: "top top",
      end: "bottom bottom",
      scrub: true,
      onUpdate(self) { scrollProgress = self.progress; }
    });

    let tprev = performance.now() * 0.001;
    function animate() {
      requestAnimationFrame(animate);
      let t = performance.now() * 0.001;
      // let tdelta = t - tprev;
      // tprev = t;
      // let tfactor = tdelta / (1/60);
    //   updateTorus(t);
    //   updateSphere(t);
      updateScatter(t);

      let pos = geometry.attributes.position.array;
      let startShape, endShape, localProg;
      if(scrollProgress < 0.20){
        updateScatter(t);
        startShape = scatterPositions;
        endShape = scatterPositions;
        localProg = 0;
      }else if(scrollProgress < 0.33){
        updateScatter(t);
        updateTorus(t);
        startShape = scatterPositions;
        endShape = torusBase;
        localProg = (scrollProgress - 0.20) / (0.33 - 0.20); 
      }else if(scrollProgress < 0.53){
        updateTorus(t);
        startShape = torusBase;
        endShape = torusBase;
        localProg = 0;
      }else if(scrollProgress < 0.66){
        updateTorus(t);
        updateSphere(t);
        startShape = torusBase;
        endShape = sphereBase;
        localProg = (scrollProgress - 0.53) / (0.66 - 0.53);
      }else if(scrollProgress < 0.86){
        updateSphere(t);
        startShape = sphereBase;
        endShape = sphereBase;
        localProg = 0;
      }else{
        updateSphere(t);
        updateScatter(t);
        startShape = sphereBase;
        endShape = scatterPositions;
        localProg = (scrollProgress - 0.86) / (1 - 0.86);
      }

      
      for (let i = 0; i < particleCount * 3; i++) {
        pos[i] = THREE.MathUtils.lerp(startShape[i], endShape[i], localProg);
      }
      geometry.attributes.position.needsUpdate = true;


      renderer.render(scene, camera);
    }
    animate();
    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
